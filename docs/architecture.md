# Architecture Documentation

## System Overview

The Refractometry IoT MVP demonstrates a production-ready telemetry architecture optimized for reliability and unattended operation.

```mermaid
graph TB
    subgraph "Device Layer"
        DEV[IoT Device<br/>C Client]
        QUEUE[Queue File<br/>queue.log]
    end
    
    subgraph "Network"
        WIFI[Wi-Fi Network]
    end
    
    subgraph "Backend Services"
        API[FastAPI Server<br/>:8000]
        DB[(PostgreSQL<br/>Database)]
    end
    
    subgraph "Frontend"
        WEB[Flutter Web<br/>Dashboard<br/>:8080]
    end
    
    DEV -->|HTTP POST| WIFI
    DEV -.offline.-> QUEUE
    QUEUE -.flush.-> DEV
    WIFI --> API
    API --> DB
    WEB -->|HTTP GET| API
    API -->|JSON| WEB
    
    style DEV fill:#e1f5ff
    style API fill:#fff4e1
    style DB fill:#e8f5e9
    style WEB fill:#f3e5f5
```

## Component Architecture

### Device Layer (C Client)

**Purpose**: Reference connectivity client demonstrating IoT device communication patterns.

**Responsibilities**:
- Read sensor values (simulated in prototype)
- Generate Refractive Index (RI) readings (range: 1.3300-1.3400)
- POST readings to backend via HTTP
- Queue readings when offline
- Flush queued readings on reconnect

**Note**: The simulator generates RI values only. Brix is supported by the API for compatibility but is not generated by the simulator, as refractometers measure RI directly.

**Key Files**:
- `main.c` - Orchestration and CLI
- `http_client.c` - HTTP POST using libcurl
- `queue.c` - File-based queue management

```mermaid
sequenceDiagram
    participant Device
    participant Queue
    participant Network
    participant Backend
    
    Note over Device: Periodic reading (e.g., 15 min)
    
    Device->>Queue: Check for queued readings
    alt Queue has entries
        loop For each queued reading
            Device->>Network: POST queued reading
            Network->>Backend: HTTP POST
            Backend-->>Network: 201 Created
            Network-->>Device: Success
        end
    end
    
    Device->>Device: Read current sensor value
    Device->>Network: POST current reading
    Network->>Backend: HTTP POST
    
    alt Network available
        Backend-->>Network: 201 Created
        Network-->>Device: Success
    else Network offline
        Network-->>Device: Connection error
        Device->>Queue: Append to queue.log
    end
```

### Backend API (FastAPI + PostgreSQL)

**Purpose**: Centralized telemetry ingestion, validation, and storage.

**Responsibilities**:
- Validate incoming readings
- Enforce idempotency via event_id
- Store readings in time-series database
- Update device last_seen_at timestamps
- Provide query endpoints for dashboard

**Key Endpoints**:
- `POST /api/v1/readings` - Ingest reading
- `GET /api/v1/devices` - List devices with status, target RI, and alert boundaries
- `GET /api/v1/devices/{id}/readings` - Reading history

**Device Configuration**:
- `target_ri` - Target Refractive Index value for process control
- `alert_low` - Lower alert boundary (warrants investigation if below)
- `alert_high` - Upper alert boundary (warrants investigation if above)

```mermaid
graph LR
    subgraph "API Layer"
        R1[POST /readings]
        R2[GET /devices]
        R3[GET /devices/:id/readings]
    end
    
    subgraph "Service Layer"
        S1[Ingest Service]
        S2[Device Service]
        V1[Validation]
    end
    
    subgraph "Data Layer"
        T1[(devices table)]
        T2[(readings table)]
    end
    
    R1 --> V1
    V1 --> S1
    S1 --> T1
    S1 --> T2
    
    R2 --> S2
    S2 --> T1
    S2 --> T2
    
    R3 --> S2
    S2 --> T2
    
    style R1 fill:#fff4e1
    style S1 fill:#e8f5e9
    style T2 fill:#e1f5ff
```

### Web Dashboard (Flutter Web)

**Purpose**: Real-time device monitoring and visualization.

**Responsibilities**:
- Display device list with status badges (OK/STALE/OFFLINE)
- Show device detail pages with time-series charts
- Display target RI and alert boundaries with visual indicators
- Auto-refresh device status every 15 seconds
- Color-code readings based on target/alert boundaries
- Handle offline/error states gracefully

**Key Pages**:
- Device List (`/`) - Table of all devices with status badges
- Device Detail (`/devices/:id`) - Chart, reading history, target RI, and alert boundaries

**Features**:
- Auto-refresh every 15 seconds on both list and detail pages
- Target RI and alert boundaries (low/high) with visual indicators
- Color-coded readings (green=at target, red=outside alerts, blue=normal)
- Device status: OK (seen <15min), STALE (15min-24h), OFFLINE (>24h)

```mermaid
graph TD
    A[Device List Page] -->|Tap device| B[Device Detail Page]
    A -->|Auto-refresh 15s| A
    B -->|Auto-refresh 15s| B
    B -->|Back| A
    
    A --> C[API: GET /devices]
    B --> D[API: GET /devices/:id/readings]
    
    C --> E[DeviceTable Component]
    D --> F[ReadingChart Component]
    D --> G[ReadingsTable Component]
    
    E --> H[StatusBadge Component]
    
    style A fill:#f3e5f5
    style B fill:#f3e5f5
    style E fill:#e1f5ff
    style F fill:#e1f5ff
```

## Data Flow

### Reading Ingestion Flow

```mermaid
sequenceDiagram
    participant Device
    participant API
    participant Validator
    participant Ingest
    participant DB
    
    Device->>API: POST /api/v1/readings<br/>{device_id, ts, value, unit}
    
    API->>Validator: Validate payload
    alt Invalid
        Validator-->>API: 400 Bad Request
        API-->>Device: Error
    else Valid
        API->>Ingest: Process reading
        
        Ingest->>DB: Check device exists
        alt Device not found
            Ingest->>DB: Create device
        end
        
        Ingest->>DB: Check event_id (if provided)
        alt Duplicate event_id
            Ingest-->>API: Return existing reading
        else New reading
            Ingest->>DB: Insert reading
            Ingest->>DB: Update device.last_seen_at
            Ingest-->>API: 201 Created
        end
        
        API-->>Device: Success
    end
```

### Device Status Calculation

```mermaid
graph TD
    A[GET /devices] --> B[Query devices table]
    B --> C[For each device]
    C --> D[Get last_seen_at]
    D --> E{Calculate age}
    
    E -->|age < 15 min| F[Status: OK<br/>Device actively reporting]
    E -->|15 min <= age < 24h| G[Status: STALE<br/>May be delayed or scheduled]
    E -->|age >= 24h| H[Status: OFFLINE<br/>Check power/network]
    E -->|never seen| H
    
    F --> I[Return device list]
    G --> I
    H --> I
```

## Design Decisions

### Wi-Fi over BLE

**Rationale**: 
- BLE is excellent for commissioning and local service workflows
- Wi-Fi/cloud is better for unattended periodic telemetry
- BLE can be fragile in production (range, OS background limits, permissions, OEM quirks)

**Trade-offs**:
- ✅ Reliable unattended operation
- ✅ No phone dependency
- ✅ Better for fleet management
- ❌ Requires Wi-Fi infrastructure
- ❌ Higher power consumption than BLE

### Store-and-Forward Queue

**Rationale**: Devices must continue operating during network outages.

**Implementation**:
- Simple file-based queue (`queue.log` in JSONL format)
- Flush on reconnect before sending current reading
- No size limits in prototype (add rotation in production)

**Trade-offs**:
- ✅ Simple, no dependencies
- ✅ Works on any filesystem
- ❌ Not suitable for high-volume production
- ❌ No transaction guarantees

### FastAPI Backend

**Rationale**: Fast development, automatic OpenAPI docs, async support.

**Trade-offs**:
- ✅ Rapid prototyping
- ✅ Type safety with Pydantic
- ✅ Auto-generated API docs
- ❌ Python runtime overhead (acceptable for API)

### Flutter Web Frontend

**Rationale**: Single codebase for web and future native mobile apps.

**Trade-offs**:
- ✅ Code reuse for native apps
- ✅ Modern UI framework
- ✅ Good performance for dashboards
- ❌ Larger bundle size than vanilla JS
- ❌ Web support is newer (but stable)

## Deployment Architecture

### Local Development

```mermaid
graph LR
    A[Docker Compose] --> B[PostgreSQL Container]
    A --> C[FastAPI Container]
    A --> D[Flutter Web Container]
    
    E[Developer Machine] -->|flutter run| F[Chrome Browser]
    E -->|make| G[C Device Client]
    
    G -->|HTTP| C
    F -->|HTTP| D
    D -->|HTTP| C
    C -->|SQL| B
```

### Production (Future)

```mermaid
graph TB
    subgraph "AWS Cloud"
        ALB[Application Load Balancer]
        
        subgraph "ECS Fargate"
            API1[API Instance 1]
            API2[API Instance 2]
        end
        
        RDS[(RDS PostgreSQL)]
        
        subgraph "S3 + CloudFront"
            WEB[Static Web Assets]
        end
    end
    
    subgraph "Field Devices"
        DEV1[Device 1]
        DEV2[Device 2]
        DEVN[Device N]
    end
    
    subgraph "Users"
        USER1[Web Browser]
        USER2[Mobile App]
    end
    
    DEV1 -->|HTTPS| ALB
    DEV2 -->|HTTPS| ALB
    DEVN -->|HTTPS| ALB
    
    ALB --> API1
    ALB --> API2
    API1 --> RDS
    API2 --> RDS
    
    USER1 -->|HTTPS| WEB
    USER2 -->|HTTPS| WEB
    WEB -->|API Calls| ALB
```

## Security Considerations

### Current (Prototype)
- HTTP (not HTTPS) for device communication
- No authentication/authorization
- No rate limiting

### Production Requirements
- TLS/HTTPS for all device communication
- API key or certificate-based device authentication
- Rate limiting per device
- Input validation (already implemented)
- SQL injection protection (SQLAlchemy ORM provides this)

## Scalability Considerations

### Current Limitations
- Single PostgreSQL instance
- No horizontal scaling for API
- File-based queue on device (not scalable for high volume)

### Production Scaling Path
- **Database**: Read replicas, connection pooling, partitioning by device_id
- **API**: Horizontal scaling with load balancer, stateless design
- **Queue**: Move to cloud message queue (SQS, RabbitMQ) or device-side SQLite
- **Caching**: Redis for device status, reduce DB load

## Monitoring and Observability

### Recommended Metrics
- Device uptime (last_seen_at tracking)
- Reading ingestion rate
- Queue depth per device
- API latency (p50, p95, p99)
- Error rates by endpoint

### Logging
- Structured JSON logs
- Device ID in all log entries
- Request/response logging for debugging

## Future Enhancements

1. **Native Mobile Apps**: Flutter native bridges for Android/iOS
2. **BLE Commissioning**: Secondary path for device setup
3. **OTA Updates**: Device firmware update mechanism
4. **Alerting**: Threshold-based alerts for readings
5. **Analytics**: Aggregated statistics and trends
6. **Multi-tenancy**: Support for multiple organizations
