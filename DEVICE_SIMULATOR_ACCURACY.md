# Device Simulator Accuracy Analysis

## Does the Simulator Accurately Reflect a Real Device?

### ✅ **YES - The simulator accurately reflects a real refractometry device**

### Accurate Behaviors

1. **Reading Generation**
   - **RI readings only** (1.3300-1.3400 range) - realistic for refractometry
   - **Note**: Refractometers measure Refractive Index (RI) directly. Brix is a derived/converted value, not a direct measurement.
   - **Temperature values** (20-30°C) - realistic ambient temperature range
   - **Event IDs** (UUID) - enables idempotency like real devices

2. **Connectivity Patterns**
   - **HTTP POST** to `/api/v1/readings` - same as real device
   - **Store-and-forward queueing** - handles offline scenarios
   - **Configurable intervals** - supports both demo (2s) and production (15min) cadences
   - **Jitter support** - simulates network timing variations
   - **Failure simulation** - tests error handling

3. **Data Format**
   - **ISO8601 timestamps** - standard format
   - **Proper JSON structure** - matches API contract
   - **Unit specification** - "RI" (Brix supported by API but not generated by simulator)
   - **Temperature optional** - matches real device flexibility

4. **Integration Behavior**
   - **Creates device automatically** - first reading creates device record
   - **Updates last_seen_at** - backend tracks device activity
   - **Idempotency support** - event_id prevents duplicates
   - **Status calculation** - OK/STALE/OFFLINE based on timing

### Differences from Real Device

1. **No Hardware Sensor** - Simulator generates random values instead of reading from sensor
2. **No Physical Constraints** - Real device may have sensor limits, calibration, etc.
3. **Simplified Queue** - Real device might use more robust storage (SQLite, etc.)

### Conclusion

The simulator **accurately reflects** the connectivity, data format, and integration patterns of a real refractometry IoT device. It's suitable for:
- ✅ Testing backend integration
- ✅ Demonstrating system behavior
- ✅ Validating API contracts
- ✅ Testing queue/offline scenarios

For production, replace simulator with actual device firmware using the C client as reference.

## Website Polling Behavior

### ✅ **YES - The website polls the database for updates**

**Polling Implementation:**
- **Device List Page**: Polls every **30 seconds** automatically
- **Device Detail Page**: Manual refresh button (no auto-polling)
- **API Endpoint**: `GET /api/v1/devices` - queries database directly

**Code Location:**
```dart
// lib/pages/index.dart
void _startPeriodicRefresh() {
  Future.delayed(const Duration(seconds: 30), () {
    if (mounted) {
      _loadDevices();  // Calls API which queries database
      _startPeriodicRefresh();
    }
  });
}
```

**Flow:**
1. Frontend calls `GET /api/v1/devices`
2. Backend queries PostgreSQL database
3. Returns current device list with latest readings
4. Frontend updates UI
5. Repeats every 30 seconds

**Real-time Updates:**
- New devices appear within 30 seconds
- Status changes (OK → STALE → OFFLINE) update automatically
- New readings appear in device list (latest reading shown)
- Device detail page requires manual refresh

### Recommendations

1. **For Real-time Updates**: Consider WebSocket support for instant updates
2. **For Production**: Reduce polling interval or use push notifications
3. **For Demo**: 30 seconds is reasonable for demonstration purposes
